C51 COMPILER V9.60.7.0   ISP_UART1                                                         02/09/2023 18:02:21 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ISP_UART1
OBJECT MODULE PLACED IN .\Objects\isp_uart1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\User\isp_uart1.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Librar
                    -y\Device\Include;..\Library\StdDriver\inc) DEBUG PRINT(.\Listings\isp_uart1.lst) TABS(2) OBJECT(.\Objects\isp_uart1.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* SPDX-License-Identifier: Apache-2.0                                                                    
             - */
   4          /* Copyright(c) 2020 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   5          /*                                                                                                        
             - */
   6          /*--------------------------------------------------------------------------------------------------------
             --*/
   7          
   8          
   9          //********************************************************************************************************
             -***
  10          //  File Function: ML51 UART0 ISP subroutine
  11          //********************************************************************************************************
             -***
  12          #include "MS51_16K.H"
  13          #include "isp_uart1.h"
  14          bit BIT_TMP;
  15          
  16            xdata volatile uint8_t uart_rcvbuf[64]; 
  17            xdata volatile uint8_t uart_txbuf[64];
  18            data volatile uint8_t bufhead;
  19            data volatile uint16_t flash_address; 
  20            data volatile uint16_t AP_size;
  21            data volatile uint8_t g_timer1Counter;
  22            data volatile uint8_t count; 
  23            data volatile uint16_t g_timer0Counter;
  24            data volatile uint32_t g_checksum;
  25            data volatile uint32_t g_totalchecksum;
  26            bit volatile bUartDataReady;
  27            bit volatile g_timer0Over;
  28            bit volatile g_timer1Over;
  29            bit volatile g_progarmflag;
  30          
  31          unsigned char PID_highB,PID_lowB,DID_highB,DID_lowB,CONF0,CONF1,CONF2,CONF4;
  32          unsigned char recv_CONF0,recv_CONF1,recv_CONF2,recv_CONF4;
  33          
  34          void MODIFY_HIRC_24(void)
  35          {
  36   1          unsigned char data hircmap0,hircmap1;
  37   1      /* Check if power on reset, modify HIRC */
  38   1      //        set_CHPCON_IAPEN;
  39   1              IAPAL = 0x38;
  40   1              IAPAH = 0x00;
  41   1              IAPCN = READ_UID;
  42   1              set_IAPTRG_IAPGO;
  43   1              hircmap0 = IAPFD;
  44   1              IAPAL = 0x39;
  45   1              IAPAH = 0x00;
  46   1              set_IAPTRG_IAPGO;
C51 COMPILER V9.60.7.0   ISP_UART1                                                         02/09/2023 18:02:21 PAGE 2   

  47   1              hircmap1 = IAPFD;
  48   1      
  49   1              TA=0XAA;
  50   1              TA=0X55;
  51   1              RCTRIM0 = hircmap0;
  52   1              TA=0XAA;
  53   1              TA=0X55;
  54   1              RCTRIM1 = hircmap1;
  55   1      //        clr_CHPCON_IAPEN;
  56   1      }
  57          
  58          void MODIFY_HIRC_16(void)
  59          {
  60   1          unsigned char data hircmap0,hircmap1;
  61   1      //    set_CHPCON_IAPEN;
  62   1          IAPAL = 0x30;
  63   1          IAPAH = 0x00;
  64   1          IAPCN = READ_UID;
  65   1          set_IAPTRG_IAPGO;
  66   1          hircmap0 = IAPFD;
  67   1          IAPAL = 0x31;
  68   1          IAPAH = 0x00;
  69   1          set_IAPTRG_IAPGO;
  70   1          hircmap1 = IAPFD;
  71   1      
  72   1          TA=0XAA;
  73   1          TA=0X55;
  74   1          RCTRIM0 = hircmap0;
  75   1          TA=0XAA;
  76   1          TA=0X55;
  77   1          RCTRIM1 = hircmap1;
  78   1      //        clr_CHPCON_IAPEN;
  79   1      }
  80          void READ_ID(void)
  81          {
  82   1      //    set_CHPCON_IAPEN;
  83   1          IAPCN = READ_DID;
  84   1          IAPAH = 0x00;
  85   1          IAPAL = 0x00;
  86   1          set_IAPTRG_IAPGO;
  87   1          DID_lowB = IAPFD;
  88   1          IAPAL = 0x01;
  89   1          set_IAPTRG_IAPGO;
  90   1          DID_highB = IAPFD;
  91   1          IAPAL = 0x02;
  92   1          set_IAPTRG_IAPGO;
  93   1          PID_lowB = IAPFD;
  94   1          IAPAL = 0x03;
  95   1          set_IAPTRG_IAPGO;
  96   1          PID_highB = IAPFD;
  97   1      }
  98          void READ_CONFIG(void)
  99          {
 100   1          IAPCN = BYTE_READ_CONFIG;
 101   1          IAPAL = 0x00;
 102   1          IAPAH = 0x00;
 103   1          set_IAPTRG_IAPGO;
 104   1          CONF0 = IAPFD;
 105   1          IAPAL = 0x01;
 106   1          set_IAPTRG_IAPGO;
 107   1          CONF1 = IAPFD;
 108   1          IAPAL = 0x02;
C51 COMPILER V9.60.7.0   ISP_UART1                                                         02/09/2023 18:02:21 PAGE 3   

 109   1          set_IAPTRG_IAPGO;
 110   1          CONF2 = IAPFD;
 111   1          IAPAL = 0x04;
 112   1          set_IAPTRG_IAPGO;
 113   1          CONF4 = IAPFD;
 114   1      //    clr_CHPCON_IAPEN;
 115   1      }
 116          
 117          void TM0_ini(void)
 118          {    
 119   1        TH0=TL0=0;    //interrupt timer 140us
 120   1        set_TCON_TR0;      //Start timer0
 121   1        set_IPH_PSH;       // Serial port 0 interrupt level2
 122   1        set_IE_ET0;
 123   1      }
 124          
 125          
 126          void UART1_ini_115200_24MHz(void)
 127          {
 128   1          SFRS = 0;
 129   1          P16_QUASI_MODE;    //Setting UART pin as Quasi mode for transmit
 130   1          P02_INPUT_MODE;    //Setting UART pin as Quasi mode for transmit  
 131   1      
 132   1          SCON_1 = 0x50;           /*UART1 Mode1,REN_1=1 */
 133   1          T3CON = 0x88;           /*T3PS2=0,T3PS1=0,T3PS0=0(Prescale=1), UART1 in MODE 1*/
 134   1          clr_T3CON_BRCK;
 135   1          RH3    = HIBYTE(65536 - 13);
 136   1          RL3    = LOBYTE(65536 - 13);
 137   1          set_T3CON_TR3;             //Trigger Timer3 
 138   1          set_EIE1_ES_1;
 139   1          EA=1;
 140   1      }
 141          
 142          
 143          void Package_checksum(void)
 144          {
 145   1        g_checksum=0;
 146   1         for(count=0;count<64;count++)
 147   1        {
 148   2          g_checksum =g_checksum+ uart_rcvbuf[count];    
 149   2        }
 150   1        uart_txbuf[0]=g_checksum&0xff;
 151   1        uart_txbuf[1]=(g_checksum>>8)&0xff;
 152   1        uart_txbuf[4]=uart_rcvbuf[4]+1;
 153   1        uart_txbuf[5]=uart_rcvbuf[5];
 154   1        if(uart_txbuf[4]==0x00)
 155   1        uart_txbuf[5]++;
 156   1        
 157   1      }
 158          
 159          
 160          void Send_64byte_To_UART1(void)
 161          {  
 162   1      //  SFRS=0;
 163   1         for(count=0;count<64;count++)
 164   1        {
 165   2           TI_1 = 0;  
 166   2          SBUF_1 = uart_txbuf[count];
 167   2          while(TI_1==0);
 168   2        }
 169   1      }
 170          
C51 COMPILER V9.60.7.0   ISP_UART1                                                         02/09/2023 18:02:21 PAGE 4   

 171          void UART1_ISR(void) interrupt 15
 172          {
 173   1      //    _push_(SFRS);
 174   1        
 175   1        SFRS=0;
 176   1          if (RI_1 == 1)
 177   1          {   
 178   2            uart_rcvbuf[bufhead++]=  SBUF_1;    
 179   2            clr_SCON_1_RI_1;                                         // Clear RI (Receive Interrupt).
 180   2          }
 181   1          if (TI_1 == 1)
 182   1          {       
 183   2              clr_SCON_1_TI_1;                                         // Clear TI (Transmit Interrupt).
 184   2          }
 185   1          if(bufhead ==1)
 186   1          {
 187   2            g_timer1Over=0;
 188   2            g_timer1Counter=90; //for check uart timeout using
 189   2          }
 190   1        if(bufhead == 64)
 191   1          {
 192   2            bUartDataReady = TRUE;
 193   2            g_timer1Counter=0;
 194   2            g_timer1Over=0;
 195   2            bufhead = 0;
 196   2          }    
 197   1      
 198   1      //    _pop_(SFRS);
 199   1      } 
 200          
 201          void Timer0_ISR (void) interrupt 1
 202          {
 203   1      //    _push_(SFRS);
 204   1        
 205   1        if(g_timer0Counter)
 206   1        {
 207   2        g_timer0Counter--;
 208   2          if(!g_timer0Counter)
 209   2          {
 210   3          g_timer0Over=1;
 211   3          }
 212   2        }
 213   1        
 214   1        if(g_timer1Counter)
 215   1        {
 216   2        g_timer1Counter--;
 217   2          if(!g_timer1Counter)
 218   2          {
 219   3          g_timer1Over=1;
 220   3          }
 221   2        }
 222   1      
 223   1      //    _pop_(SFRS);
 224   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    786    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    140    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17       4
C51 COMPILER V9.60.7.0   ISP_UART1                                                         02/09/2023 18:02:21 PAGE 5   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
